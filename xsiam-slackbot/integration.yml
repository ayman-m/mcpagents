commonfields:
  id: ESET-Slack
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: ESET-Slack
display: ESET-Slack
category: Messaging and Conferencing
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAF8ElEQVRo3tVaa2wUVRQ+lUeolLZQHwQxEUIi/GgpakvTst2d7fax7RaEUFOIRW2x7e7cme220BawNSQ1MQZFgYaH8gvlFVAxUYIIJPxRA7FSLCpBJMYnL5FEyh8cvzttodvd6e527izpJCezO3Pn3Pvde853zzkzRKKPAmUOScp+Kg/MoVF7FCiZJLHz5JA1nL8jlzxzxLoklgw908iBc5xBZKPTSzqIAcmvPU3Ltk+NSc/S5vGUz9YASBd0XIXOb2jpKm+cQDAnOvw9CAQXm1ej0ubj9PW5yVHpaXplLJU3bKN83xA9+F+gtJAnkGAdCIm50dm1EBADYgeYrJrDlF0d2UTscj7ZfXcMdN2kJW2PWwPCIZdC/jYEESwHATopwsquHVZHgb9IPAinvhI3owTRJ5L8ITm8xisjye8N+7xLtQk2JyUHPnElJhB3CcB7hCpff9TATI8bPmfzXUCfqeJAuPyzoPinEYEYkMKGr8jtnztkhbmZ3gr1MYiTXaPFgWKRFDuenMpBUyD0wemsBGqVt2EVWmgRmMoh3wjTthdAdlGpP120cz8EO/7FNJBQswm95mR7qKTBoujAqUzADJ4QDiREWDe5lInWbn5FgWysyiEAOmNgDuZFkt+N107+AGw3hUrU6VSsLsTvo4LBHMFEJVDcD7syBh1vEQikFz5SRPflkNRU2PY5cebF/oBPLjM/sMWBVEShKpRuJxeLjsMdyibx/sL2UUXHCNmrtiUZ9n/0bhSaW3uL1A2RuVxiqy1ismvQvR7ycKxx1GuUP0hRdo1GLVvfjsK8NlpMzRdhbowKlSmRQVSumg/kt4csr0Y5dZepyvuEMXh/Ctr1kA1t56vDC28jmaLnbkQZ9VSoJhqxzzh08rmhguyXPqI9xxINzOotPsDkhbXavMZlWmZgeVjh93gbHYx5//kWYFZQkfLg0P2hAg3+M3xwQb1GFe0nacVaDz3XOB3m9xiU5UP64i/M9rzG5dq+6xnanqsZ2u4rc4OEX+P3eBt9ZYQRgnf/4IAwERe7IsyARnl1PBTX9IRKYteD7mNwfNb5gD+4nKG9/9fcIOHX+D3eRggQbp42Pp616wYBUVeaVtwPhM8+H/iuPzODhF/j94QB4RNaFviR1h1K6wPxYkcyZvqHUQckC2y6utN3bzWatzDKqtZGHZDcuh56oWNSH4h3dqRRSdP5frsfXUAkVn1vNTxyO+V5zfG6GGe/ohMIn1BOKFJEej5NBfKEwfHRAWE0OBL6ldh+0H4ussRpOqVXrfFQRdtJneqN+7qD+G9J8N7hbkzEalRBusynrDFuiE7lzbCbK990s6s/Ns732WGkweMMQgxs95JSB0BnzPF61CHKWVC+cY1rZWAG5fmuhs1Vlq96JprsbzLyZRmoL1gaADrZGxHHsiSwKagwwUtDLmV9rBEwKiasvb9sY0FezgIRx/BsUybCoN5Bz32G2CppZLlJTfNssrO94sEoG6MrCLIytN8KS/EB/CQBNS1WCflNIJgeOHvKfcrLlULd2YT5ibwZ5zHxB+JAicbBjgg1MV5KcjcuIk/TdFBrKnwzTsCcyk6LmIynBd04f0Lu1qctNi05CZ2dtbxkKiknyNmQaA0Il5qOTkLDmZyXrQDzMyRNLACPmgmlu+Ebt0MTG991Yhs6sUM34n6nvufYTfsMJ4G9VMjGigNR0+LRbTf84P4lW31wWdOtZlCx8qUpMPw9fZEyUxyI1rYpCA8uGQ5Kkr8I+5y39RFa4Ds8QiCXwVpZYk2q1C9FeIexw/BZm5yMmY01PbgBJ7egcF3oLxnWjl1Kc4Ty6USAPRBDSbTYGpZqacMGJf8TvnqBxEaS8yLqyKpJhnyqfzRgHPrzzzQsfIWweE0CuHw12euHMpVG5f7N+Nwiuh2Yf77hbj6mf84Rap6/YoO1x2cnL3m1Dp2e0h1RwtkuB5CSxhZGPL9zKj4UONX/NncAxEWS/E/FOcaSJ+mfHDlNhNFlrTP0l5x9weL38LF0GrWHq2m2/uLGpT4pWvX/zRDqQjZWrVoAAAAASUVORK5CYII=
description: Slack Bot integration that monitor mentions and allows for remote command
  execution through XSOAR or XSIAM.
detaileddescription: |-
  Slack-facing interface for the shared MCP/Gemini agent. Runs as a long-running job in Cortex XSIAM/XSOAR after importing this integration. On mentions/DMs, it routes requests to Gemini, which can call MCP tools, and posts results back to Slack.

  ### Key parameters
  - Slack: `slack_bot_token`, `slack_app_token`
  - XSIAM: `platform_url`, `api_key`, `api_key_id`
  - MCP: `mcp_uri` (e.g., `https://<host>:9010/api/v1/stream/mcp`), `mcp_api_key` (bearer token)
  - Gemini/Vertex: `gemini_api_key` **or** `google_creds_json` (service account JSON)
  - Optional: `insecure` (disable SSL verify), `proxy`, `debug_start`, `longRunning`

  ### Deployment
  1. Import `integration.yml` into Cortex XSIAM/XSOAR.
  2. Set the parameters above.
  3. Enable as a long-running instance; invite the bot to channels and mention it to trigger actions.
configuration:
- supportedModules: []
  display: Select a Platform
  name: platform
  defaultvalue: XSIAM
  type: 15
  required: false
  options:
  - XSOAR
  - XSIAM
- supportedModules: []
  display: Platform URL (e.g. https://soar.monstersofhack.com)
  name: platform_url
  defaultvalue: https://soar.monstersofhack.com
  type: 0
  required: true
- supportedModules: []
  display: ""
  displaypassword: Platform API Key ID
  name: api_key_id
  type: 9
  required: true
  hiddenusername: true
- supportedModules: []
  display: ""
  displaypassword: Platform API Key
  name: api_key
  type: 9
  required: true
  hiddenusername: true
- supportedModules: []
  display: ""
  displaypassword: Slack Bot Token
  name: slack_bot_token
  type: 9
  required: true
  hiddenusername: true
- supportedModules: []
  display: ""
  displaypassword: Slack App Token
  name: slack_app_token
  type: 9
  required: true
  hiddenusername: true
- supportedModules: []
  display: Trust any certificate (not secure)
  name: insecure
  type: 8
  required: false
- supportedModules: []
  display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- supportedModules: []
  display: Debug Mode
  name: debug_start
  defaultvalue: "false"
  type: 8
  required: false
- supportedModules: []
  display: Long running instance
  name: longRunning
  type: 8
  required: false
- supportedModules: []
  display: Alert type
  name: alertType
  type: 13
  required: false
- supportedModules: []
  display: XSIAM MCP URI
  name: mcp_uri
  type: 0
  required: false
- supportedModules: []
  display: XSIAM MCP Key
  name: mcp_api_key
  type: 4
  required: false
- supportedModules: []
  display: Vertex AI JSON Creds
  name: google_creds_json
  type: 4
  required: false
script:
  commands:
  - supportedModules: []
    name: bh-dependencies-check
    arguments: []
    description: A command to check the dependencies health
  - supportedModules: []
    name: slackbot-download-thread-file
    arguments:
    - supportedModules: []
      name: file_link
      required: true
      description: Link to download the file
    - supportedModules: []
      name: file_name
      description: File name
    description: A command to download a slack file from a thread
  - supportedModules: []
    name: slackbot-get-thread-messages
    arguments:
    - supportedModules: []
      name: channel_id
      required: true
      description: Channel ID
    - supportedModules: []
      name: thread_id
      description: Thread ID
    description: Get thread messages
  script: |
    import os
    import asyncio
    import shlex
    import re
    import json
    import urllib3
    import requests
    import time
    import random
    from slack_bolt import App
    from slack_bolt.adapter.socket_mode import SocketModeHandler
    from slack_sdk import WebClient
    from slack_sdk.webhook import WebhookClient
    from slack_sdk.errors import SlackApiError
    from google import genai
    from google.genai import types
    from google.oauth2 import service_account
    import httpx
    from fastmcp import Client
    from fastmcp.client.transports import StreamableHttpTransport

    # --- Agent / MCP Integration ---

    def unverified_client_factory(**kwargs):
        """Factory to create an unverified httpx client for MCP."""
        kwargs["verify"] = False
        return httpx.AsyncClient(**kwargs)

    class CortexMCPClient:
        def __init__(self, uri, key):
            self.base_url = uri
            self.api_key = key
            self.client = None

            # Configure transport with unverified client factory
            transport = StreamableHttpTransport(
                url=self.base_url,
                httpx_client_factory=unverified_client_factory
            )

            # Initialize Client with custom transport and auth
            self.client = Client(transport, auth=self.api_key)

        async def __aenter__(self):
            await self.client.__aenter__()
            return self

        async def __aexit__(self, exc_type, exc_val, exc_tb):
            if self.client:
                await self.client.__aexit__(exc_type, exc_val, exc_tb)

        async def list_tools(self):
            return await self.client.list_tools()

        async def call_tool(self, name, arguments=None):
            return await self.client.call_tool(name, arguments)



    # Custom logging filter
    class CustomFilter(logging.Filter):
        def filter(self, record):
            return 'Bolt app is running!' not in record.getMessage()


    # Set up logging
    slack_logger = logging.getLogger("internal_slack")
    slack_logger.addFilter(CustomFilter())

    # Globals and constants
    SEVERITY_DICT = {'Unknown': 0, 'Low': 1, 'Medium': 2, 'High': 3, 'Critical': 4}


    LONG_RUNNING_ENABLED = demisto.params().get('longRunning', True)

    PLATFORM = demisto.params().get('platform', "XSIAM").lower()
    SSL_VERIFY = demisto.params().get('unsecure', False)
    DEBUG_START = demisto.params().get('debug_start', False)
    BOT_TOKEN = demisto.params().get('slack_bot_token', {}).get('password', '')
    APP_TOKEN = demisto.params().get('slack_app_token', {}).get('password', '')
    PLATFORM_URL = demisto.params().get('platform_url')
    API_KEY = demisto.params().get('api_key', {}).get('password', '')
    API_KEY_ID = demisto.params().get('api_key_id', {}).get('password', '')

    os.environ["SLACK_BOT_TOKEN"] = BOT_TOKEN
    os.environ["SLACK_APP_TOKEN"] = APP_TOKEN

    proxies = handle_proxy()
    proxy_url = proxies.get('http')  # aiohttp only supports http proxy



    app = App(token=BOT_TOKEN, logger=slack_logger)


    #######################
    # Platform Clients
    #######################



    class XSIAMClient:
        def __init__(self, url, api_key, api_key_id):
            self.url = url
            self.api_key = api_key
            self.headers = {
                "Authorization": api_key,
                "x-xdr-auth-id": api_key_id,
                "Content-Type": "application/json"
            }

        def health(self):
            try:
                response = requests.get(f"{self.url}/public_api/v1/healthcheck", headers=self.headers, verify=SSL_VERIFY)
                response.raise_for_status()
                return response.text
            except requests.RequestException as e:
                demisto.error(f"Error checking XSIAM health: {e}")
                raise

        def create_incident(self, incident_type, incident_owner, incident_name, incident_severity, incident_detail):
            incident_detail = "incident_owner=" + incident_owner+"\nincident_name=" + incident_name + "\nincident_severity=" + str(incident_severity) + "\n" + incident_detail
            data = {
                "request_data": {
                    "alert": {
                    "vendor": "Cortex",
                    "product": "TroyBot",
                    "severity": "Medium",
                    "category": incident_type,
                    "mitre_defs": {},
                    "description": incident_detail,
                    }
                }
            }
            try:
                response_api = requests.post(self.url + "/public_api/v1/alerts/create_alert", headers=self.headers,
                                             data=json.dumps(data),
                                             verify=SSL_VERIFY)
            except requests.RequestException as e:
                demisto.error(f"Error creating XSIAM incident: {e}")
                raise
            else:
                return response_api.text

        def search_incident(self, filters={}):
            filters = {
                "request_data": filters
            }
            try:
                response = requests.post(f"{self.url}/public_api/v1/alerts/get_alerts/", headers=self.headers,
                                         json=filters, verify=SSL_VERIFY)
                response.raise_for_status()
                return response.text
            except requests.RequestException as e:
                demisto.error(f"Error searching XSIAM incidents: {e}")
                raise


    def get_client(platform, url, api_key, api_key_id):
        return XSIAMClient(url, api_key, api_key_id)


    def get_incident_link(platform_client, platform, url, incident_dict):

        """
        Attempts to find the external ID for an incident, retries up to 5 times with a 1-second delay.
        Args:

            platform_client: Client instance to interact with the platform.
            platform (str): Platform name ('xsoar' or 'xsiam').
            url (str): Base URL for generating the incident link.
            incident_dict (dict): Incident details dictionary.
        Returns:
            str: Generated incident link.
            str: Case ID (for 'xsiam').
        Raises:
            ValueError: If the platform is unsupported or if the external ID cannot be matched.
        """

        url = url.replace('api-', '')

        if platform == 'xsiam':
            case_uuid = str(incident_dict['reply']).strip()
            case_id = None
            for attempt in range(5):  # Retry up to 5 times
                cases = return_dict(platform_client.search_incident())
                for case in cases['reply']['alerts']:
                    if case['external_id'] == case_uuid:
                        case_id = case['alert_id']
                        break
                if case_id:
                    break  # Exit loop if case_id is found
                else:
                    time.sleep(1)  # Wait for 1 second before retrying
            if not case_id:
                demisto.error(f"Could not match external_id '{case_uuid}' after 5 retries.")
            incident_link = url + "/alerts?action:openAlertDetails=" + str(case_id) + "-caseinfoid"
            return incident_link, str(case_id)
        else:
            demisto.error(f"Unsupported platform: {platform}")




    #######################
    # Helper Functions
    #######################

    def get_user_name(user_id):
        try:
            response = app.client.users_info(user=user_id)
            return response['user']['name']
        except Exception as e:
            demisto.error(f"The Loop has failed to run {str(e)}")

    def clean_urls(url_str):
        ret_str = ""
        i = 0
        val_list = url_str.split(",")
        for val in val_list:
            i = i + 1
            domain_str = val.split("|")
            ret_str = ret_str + domain_str[0].replace("<", "")
            if i < len(val_list):
                ret_str = ret_str + ","
        return ret_str

    def clean_domains(dom_str):
        ret_str = ""
        i = 0
        val_list = dom_str.split(",")
        for val in val_list:
            i = i + 1
            if "|" in val:
                domain_str = val.split("|")
                ret_str = ret_str + domain_str[1].replace(">", "")
            if i < len(val_list):
                ret_str = ret_str + ","
        return ret_str

    def clean_emails(email_str):
        ret_str = ""
        i = 0
        val_list = email_str.split(",")

        if val_list == -1:
            if "|" in val_list:
                domain_str = email_str.split("|")
                email_str = ret_str + domain_str[1].replace(">", "")
            if is_email(email_str):
                ret_str = email_str
        else:
            for val in val_list:
                i = i + 1
                if "|" in val:
                    domain_str = val.split("|")
                    ret_str = ret_str + domain_str[1].replace(">", "")
                if is_email(val):
                    ret_str = val
                if i < len(val_list) and is_email(ret_str):
                    ret_str = ret_str + ","
        return ret_str

        return ret_str

    def get_gemini_response(text, history=None):
        """
        Get response from Gemini for the Slack thread, using MC-enabled Agent loop.
        """
        # Retrieve configuration from demisto.params()
        params = demisto.params()
        mcp_uri = params.get('mcp_uri')

        # Safe retrieval helper
        def get_safe_param(key, default=''):
            val = params.get(key)
            if isinstance(val, dict):
                return val.get('password', default)
            return val or default

        mcp_key = get_safe_param('mcp_api_key')
        gemini_api_key = get_safe_param('gemini_api_key')

        # Optional JSON creds via param
        google_creds_json = get_safe_param('google_creds_json')
        google_creds = None
        if google_creds_json:
            try:
                google_creds = json.loads(google_creds_json)
            except:
                demisto.error("Failed to parse google_creds_json")

        # If parameters not in demisto.params, fallback to Env (legacy support)
        if not mcp_uri:
            mcp_uri = os.environ.get("CORTEX_CRAFTER_MCP_URI")
        if not mcp_key:
            mcp_key = os.environ.get("CORTEX_CRAFTER_MCP_KEY")
        if not gemini_api_key:
            gemini_api_key = os.environ.get("GEMINI_API_KEY")

        if not mcp_uri:
           return "Configuration Error: MCP URI is missing in integration parameters."

        # Run Async Agent Loop
        try:
            # Since this might be called from within a sync context in Slack Bolt,
            # we need to be careful with asyncio.run().
            # If there is already a running loop, we should use it.
            # However, integration usually runs as a script.
            # But Bolt uses asyncio? No, Bolt for Python default adapter is likely sync,
            # but 'socket_mode' might use async internally or threads.

            # Simple approach: asyncio.run()
            response = asyncio.run(run_agent_async(
                prompt=text,
                mcp_uri=mcp_uri,
                mcp_key=mcp_key,
                gemini_api_key=gemini_api_key,
                google_creds=google_creds,
                history=history
            ))
            return response
        except Exception as e:
            demisto.error(f"Agent Execution Failed: {e}")
            return f"Agent Error: {str(e)}"

    # --- Agent Logic ---

    def sanitize_schema(s, defs=None, depth=0, processing=None):
        if not isinstance(s, dict):
            return s

        if depth > 10:
            return {"type": "object", "description": "Complex/Deeply nested object"}

        processing = processing or set()

        current_defs = defs or {}
        if "$defs" in s:
            current_defs.update(s.pop("$defs"))
        if "definitions" in s:
            current_defs.update(s.pop("definitions"))

        if "$ref" in s:
            ref = s.pop("$ref")
            ref_name = ref.split("/")[-1]

            if ref_name in processing:
                return {"type": "object", "description": f"Recursive reference to {ref_name}"}

            if ref_name in current_defs:
                processing.add(ref_name)
                try:
                    resolved = sanitize_schema(
                        current_defs[ref_name].copy(),
                        current_defs,
                        depth + 1,
                        processing.copy()
                    )
                    s.update(resolved)
                finally:
                    processing.discard(ref_name)
            else:
                 s["type"] = "string"
                 s["description"] = f"Reference to {ref_name}"

        complex_keys = ["oneOf", "anyOf", "allOf"]
        found_complex = False
        for key in complex_keys:
            if key in s:
                found_complex = True
                del s[key]

        if found_complex:
            s["type"] = "object"
            s["description"] = s.get("description", "Complex variant type") + " (Validation simplified)"
            return s

        if "properties" in s:
            for k, v in s["properties"].items():
                s["properties"][k] = sanitize_schema(v, current_defs, depth + 1, processing)

        if "items" in s:
            s["items"] = sanitize_schema(s["items"], current_defs, depth + 1, processing)

        return s

    async def run_agent_async(prompt, mcp_uri, mcp_key, gemini_api_key=None, google_creds=None, history=None):
        """
        Core agent event loop similar to agent-slackx, but returning the response string.
        """

        # Setup Gemini Client
        client = None
        model_name = os.environ.get("GEMINI_MODEL", "gemini-3-pro-preview")
        location = "us-central1"
        if "gemini-3" in model_name.lower() or "experimental" in model_name.lower():
            location = "global"

        if gemini_api_key:
            client = genai.Client(api_key=gemini_api_key)
        elif google_creds:
            try:
                # Create credentials logic with explicitly required scope
                scopes = ['https://www.googleapis.com/auth/cloud-platform']
                credentials = service_account.Credentials.from_service_account_info(google_creds, scopes=scopes)
                project_id = google_creds.get("project_id")

                if credentials:
                    # Initialize Vertex AI client with explicit credentials
                    client = genai.Client(vertexai=True, project=project_id, location=location, credentials=credentials)
                    demisto.debug("Initialized Gemini Client with Service Account credentials.")
            except Exception as e:
                demisto.error(f"Failed to load Google credentials: {e}")

        if not client:
            # Fallback to env usually set by XSOAR params/docker
            try:
                # If no key passed but creds path logic exists
                 client = genai.Client(vertexai=True, location=location) # Try default
            except:
                 return "Error: No valid Gemini configuration."

        demisto.debug(f"Agent interacting with model: {model_name} at {location}")

        # Connect to MCP
        async with CortexMCPClient(mcp_uri, mcp_key) as mcp_client:
            tools_list = []
            try:
                raw_tools = await mcp_client.list_tools()
                tools_data = raw_tools if isinstance(raw_tools, list) else raw_tools.tools

                # Sanitize and convert to Gemini Tool
                gemini_funcs = []
                for t in tools_data:
                    schema = getattr(t, "parameters", getattr(t, "inputSchema", {}))
                    clean_schema = sanitize_schema(schema.copy())
                    gemini_funcs.append(types.FunctionDeclaration(
                        name=t.name,
                        description=t.description,
                        parameters=clean_schema
                    ))

                if gemini_funcs:
                    tools_list = [types.Tool(function_declarations=gemini_funcs)]
                    demisto.debug(f"Loaded {len(gemini_funcs)} MCP tools.")

            except Exception as e:
                demisto.error(f"MCP Connection Warning: {e}")
                # Continue without tools

            # Chat Config
            config = types.GenerateContentConfig(
                system_instruction="""You are an advanced Security Analyst Agent in the Troy Security Operations Center (SOC).
    Your mission is to protect the Troy network assets from external and internal threats, utilizing a multi-vendor, integrated SOC/NOC architecture.

    **The Environment & Topology:**
    The architecture is a centralized SOC/NOC stack where **Palo Alto Networks (Cortex XSIAM)** acts as the "Central Brain" for analytics and response.

    **1. Palo Alto Networks (Central Operations):**
    - **Role**: Primary security analytics, threat prevention, file analysis, and orchestration layer.
    - **Capabilities**: Cortex XSIAM (SOC Platform), Strata (Network Security), Advanced Threat Prevention, IoT Security, AIOps.
    - **Flow**: Ingests logs from Cisco, Arista, Coerelight; Orchestrates response actions to Arista.

    **2. Arista (Network Fabric & Enforcement):**
    - **Role**: Provides switching/wireless infrastructure, network visibility, and enforcement.
    - **Capabilities**: CV-CUE, CloudVision, AGNI.
    - **Flow**: Sends logs to Palo Alto; **Enforces responses** (e.g., Device Quarantine) triggered by Palo Alto; Mirrors traffic (Taps) to Corelight.

    **3. Corelight (Network Detection & Response - NDR):**
    - **Role**: Deep packet inspection and behavioral analytics.
    - **Capabilities**: Zeek, Suricata, Yara, Smart PCAP.
    - **Flow**: Receives raw traffic from Arista Taps; Sends enriched NDR telemetry/logs to Palo Alto.

    **4. Cisco (Security Cloud & Telemetry):**
    - **Role**: Identity, endpoint, cloud, and IoT telemetry provider.
    - **Capabilities**: ThousandEyes (Monitoring), Meraki (IoT/Cameras), Duo (Identity), Splunk Attack Analyzer.
    - **Flow**: Sends logs and suspicious file submissions to Palo Alto.

    **Data Flow Summary:**
    - **Logs**: Arista/Cisco/Corelight -> Palo Alto (XSIAM).
    - **Response**: Palo Alto -> Arista (Blocking/Quarantine).
    - **Taps**: Arista -> Corelight (Inspection).
    - **Files**: Cisco -> Palo Alto (Analysis).

    **Your Persona & Guidelines:**
    - **Team Member**: You are not a robot; you are a valued member of the Troy SOC team. Act like a colleague—be collaborative, encouraging, and clear. Your handle on slack starts with ESET so you are able to recgonize your own messages in a thread if called multiple times
    - **Human-Like**: Use natural language. Avoid overly robotic phrasing. It's okay to show personality (e.g., "Good catch!", "Let's dig into this.").
    - **Vigilant**: Expect hostile traffic from the Training Rooms (Internal) and Registration Servers (External).
    - **Context-Aware**: Understand that an alert from Corelight or Arista isn't isolated—it feeds into XSIAM. Use this context for correlation.
    - **Subnet Lookup**: You MUST use the `agentic_subnet_lookup` dataset to identify the physical location/purpose of an IP (e.g., "Which training room is this?").
    - **Reporting**: Cite specific tools and flows (e.g., "I'm seeing a correlation in XSIAM matching the Corelight NDR hits...").
    - **Recommendations**: We don't block students or guests at Troy , so don't including blocking in your recommendations if you think the ip is local not external attacker.
    - **Safty**: Defang URL's before sharing them with analysts .
    """,
                tools=tools_list,
                automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=True) # We handle manually
            )

            chat = client.chats.create(model=model_name, config=config)

            # Prepare context (history + prompt)
            full_text = prompt
            if history:
                 # Basic history injection
                 full_text = f"Context:\n{history}\n\nTask:\n{prompt}"

            # Turn 1
            response = await send_message_with_backoff(chat, full_text)

            # Loop for tool calls
            for _ in range(10): # Max turns
                try:
                    content = response.candidates[0].content
                except IndexError:
                    break

                # Collect all function calls in this turn
                function_calls = []
                for part in content.parts:
                    if part.function_call:
                        function_calls.append(part.function_call)

                if function_calls:
                    # We have tool calls to execute
                    response_parts = []

                    for fc in function_calls:
                        tool_name = fc.name
                        tool_args = fc.args

                        demisto.debug(f"Agent invoking tool calling: {tool_name}")

                        try:
                            # Call MCP Tool
                            tool_result = await mcp_client.call_tool(tool_name, tool_args)
                            result_str = str(tool_result)

                            response_parts.append(
                                types.Part.from_function_response(
                                    name=tool_name,
                                    response={"result": result_str}
                                )
                            )
                        except Exception as e:
                            demisto.error(f"Tool {tool_name} failed: {e}")
                            response_parts.append(
                                types.Part.from_function_response(
                                    name=tool_name,
                                    response={"error": str(e)}
                                )
                            )

                    # Send ALL results back to the model in one go
                    response = await send_message_with_backoff(chat, response_parts)

                else:
                    # No function calls, check for text response
                    for part in content.parts:
                        if part.text:
                            return part.text

                    # If we got here, we got content but no text and no function calls?
                    # Probably safety filter or empty.
                    return "No text response generated."

        return "No final response generated."


    def is_email(email):
        regex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        if re.fullmatch(regex, email):
            return True
        else:
            return False

    # --- Rate Limit Helper ---

    async def send_message_with_backoff(chat_session, content, max_retries=5, initial_delay=2):
        """
        Sends a message to the Gemini chat session with exponential backoff for 429 errors.
        """
        retries = 0
        delay = initial_delay

        while retries <= max_retries:
            try:
                return chat_session.send_message(content)
            except Exception as e:
                # Check for 429 or RecourceExhausted
                error_msg = str(e)
                if "429" in error_msg or "Resource exhausted" in error_msg or "RESOURCE_EXHAUSTED" in error_msg:
                    retries += 1
                    if retries > max_retries:
                        demisto.error(f"Max retries exceeded for Gemini 429 error: {e}")
                        raise e

                    # Add jitter
                    sleep_time = delay + random.uniform(0, 1)
                    demisto.info(f"Hit 429 error. Retrying in {sleep_time:.2f} seconds... (Attempt {retries}/{max_retries})")
                    await asyncio.sleep(sleep_time)
                    delay *= 2  # Exponential backoff
                else:
                    # Re-raise other errors immediately
                    raise e


    # --- History Helper ---

    def fetch_formatted_history(channel_id, thread_ts=None, limit=20):
        """
        Fetches and formats message history from a thread or channel.
        """
        user_messages = []
        try:
            if thread_ts:
                response = app.client.conversations_replies(channel=channel_id, ts=thread_ts)
            else:
                # For channel history, we want the *latest* messages,
                # so we fetch them and then reverse the list to put them in chronological order
                # for the model context.
                response = app.client.conversations_history(channel=channel_id, limit=limit)

            messages = response['messages']
            # If fetching channel history, reverse to chronological order
            if not thread_ts:
                messages = messages[::-1]

            for message in messages:
                # Skip bot messages if desired, but user asked for "all communications"
                # We usually skip the invocation message itself to avoid infinite loops,
                # but here we just want context.
                if message.get("subtype"):
                    continue

                msg_text = message.get('text', '')

                user_id = message.get('user')
                user_name = "Unknown"
                if user_id:
                    user_name = get_user_name(user_id)

                msg_data = {
                    'user_id': user_id,
                    'user_name': user_name,
                    'timestamp': message['ts'],
                    'text': msg_text
                }

                if "files" in message:
                    file_info = []
                    for file in message["files"]:
                        f_url = file.get("url_private_download", "")
                        f_name = file.get("name", "")
                        f_type = file.get("mimetype", "")
                        file_info.append(f"filename={f_name} filetype={f_type} download_link={f_url}")
                    msg_data['file'] = ", ".join(file_info)

                user_messages.append(msg_data)

        except SlackApiError as e:
            demisto.error(f"Error fetching history: {e}")

        return user_messages

    def is_ip(ip):
        regex = r"^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\." \
                r"(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\." \
                r"(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\." \
                r"(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])$"
        if re.fullmatch(regex, ip):
            return True
        return False

    def is_sha256(sha256):
        regex = "[A-Fa-f0-9]{64}"
        if re.fullmatch(regex, sha256):
            return True
        else:
            return False

    def is_mac(mac):
        regex = "([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})"
        if re.fullmatch(regex, mac):
            return True

        else:
            return False

    def check_key(dict_obj, key):
        if key in dict_obj.keys():
            return True
        else:
            return False


    #######################
    # Slack Event Section
    #######################

    @app.event("app_home_opened")
    def update_home_tab(client: WebClient, event: dict, logger):
        """
        Event handler for 'app_home_opened' event.

        This function updates the home tab with a welcome message when the app home is opened.
        """
        user_id = event["user"]
        try:
            client.views_publish(
                user_id=user_id,
                view={
                    "type": "home",
                    "blocks": [
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": "Welcome to *SlackBot*! :wave:\n\nUnveiling the untold, "
                                        "one story at a time. Work in progress .."
                            }
                        },
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": "*Features*"
                            }
                        },
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": ":microphone: *Voice to Text*:\nSlackBot can transcribe your voice notes "
                                        "into text using the Whisper ASR system."
                            }
                        },
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": ":speech_balloon: *Text-Based AI Chat*:\nSlackBot uses OpenAI's GPT-3 model "
                                        "to comprehend the context and generate a response."
                            }
                        },
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": ":speaker: *Text to Voice*:\nSlackBot converts the generated text response "
                                        "into voice using the Eleven Labs Text-to-Speech service, providing a "
                                        "voice-enabled conversational experience."
                            }
                        }
                    ]
                }
            )
        except SlackApiError as e:
            logger.error(f"Error updating home tab for user {user_id}: {e}")


    @app.event("team_join")
    def ask_for_introduction(event, say):
        user_id = event['user']
        text = f"Welcome to the team, <@{user_id}>!"
        say(text=text)



    @app.event("app_mention")
    def handle_app_mention(body, say):
        if check_key(body['event'], 'user'):
            user = body['event']['user']
        else:
            user = body['event']['bot_id']
        text = body['event']['text']
        channel = body['event']['channel']
        bot_handle = body['authorizations'][0]['user_id']
        text = text.replace(f"<@{bot_handle}>", "")  # Remove the bot handle

        # Check if inside a thread
        is_thread = "thread_ts" in str(body)
        thread_ts = body['event'].get('thread_ts', body['event']['ts'])

        platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
        channel_id = body['event']['channel']
        channel_info = app.client.conversations_info(channel=channel_id)
        channel_name = channel_info['channel']['name']

        # Fetch History (Thread or Channel)
        user_messages = fetch_formatted_history(channel_id, thread_ts if is_thread else None)

        # Log Incident (Preserve existing logic for threads)
        if is_thread:
            mytext = "thread_id=" + thread_ts + "\nchannel_id=" + channel_id + "\nchannel_name=" + channel_name + "\nthread_messages=" + str(user_messages)
            try:
                 platform_client.create_incident("Troy Monitored Thread", "",
                                             f"Troy Monitored Thread Incident, Thread: {thread_ts}"
                                             , SEVERITY_DICT['Low'], mytext)
            except Exception as e:
                 demisto.error(f"Failed to create incident: {e}")

        # --- Gemini Integration ---
        gemini_reply = get_gemini_response(text, history=user_messages)

        # Reply (In thread if it was a thread, or start a new thread if it was a channel mention)
        say(text=gemini_reply, thread_ts=thread_ts)
        # ---------------------------


    @app.event("message")
    def handle_message_events(body, logger, say):
        """
        Event handler for generic 'message' events (e.g. DMs).
        """
        event = body.get("event", {})

        # 1. Ignore bot messages / subtypes (like channel_join) to prevent loops
        if event.get("bot_id") or event.get("subtype"):
            return

        # 2. Ignore non-DM messages (Channel/Thread messages must strictly use app_mention)
        if event.get("channel_type") != "im":
            return

        text = event.get("text")
        ts = event.get("ts")
        user = event.get("user")

        # 2. Process message via Gemini
        if text:
            try:
                # We can retrieve thread history here if we want to be fancy,
                # but for now, essentially just respond to the text.
                # If it's a thread reply, 'thread_ts' will be present.

                thread_ts = event.get("thread_ts", ts)

                # Use the existing helper
                response = get_gemini_response(text)

                say(text=response, thread_ts=thread_ts)

            except Exception as e:
                logger.error(f"Error handling message event: {e}")
                say(f"I encountered an error processing your message: {e}", thread_ts=ts)


    #######################
    # Slack Command Section
    #######################




    @app.command("/my-incidents")
    def handle_my_incidents_command(ack, body, say):
        ack()
        blocks = [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "This command is temporarly disabled .."
                }
            }
        ]
        webhook = WebhookClient(body.get("response_url"))
        webhook.send(blocks=blocks)


    @app.command("/check-ioc")
    def handle_check_ioc(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        ioc_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Check IOC",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "IOC Type"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Select an type",
                        "emoji": True
                    },
                    "options": [
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "SHA256",
                                "emoji": True
                            },
                            "value": "sha256"
                        }, {
                            "text": {
                                "type": "plain_text",
                                "text": "IP Address",
                                "emoji": True
                            },
                            "value": "ip"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "URL",
                                "emoji": True
                            },
                            "value": "url"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Email",
                                "emoji": True
                            },
                            "value": "email"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Domain",
                                "emoji": True
                            },
                            "value": "domain"
                        }
                    ],
                    "action_id": "check_ioc_select_ioc_type"
                }
            }
        ]
        webhook.send(blocks=ioc_block)

    @app.command("/dev-check-ioc")
    def handle_dev_check_ioc(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        ioc_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Check IOC",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "IOC Type"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Select an type",
                        "emoji": True
                    },
                    "options": [
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "SHA256",
                                "emoji": True
                            },
                            "value": "sha256"
                        }, {
                            "text": {
                                "type": "plain_text",
                                "text": "IP Address",
                                "emoji": True
                            },
                            "value": "ip"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "URL",
                                "emoji": True
                            },
                            "value": "url"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Email",
                                "emoji": True
                            },
                            "value": "email"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Domain",
                                "emoji": True
                            },
                            "value": "domain"
                        }
                    ],
                    "action_id": "check_ioc_select_ioc_type"
                }
            }
        ]
        webhook.send(blocks=ioc_block)


    @app.command("/check-ip")
    def handle_check_ip_command(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        ip_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Check An IP Address",
                    "emoji": True
                }
            },
            {
                "type": "input",
                "block_id": "ip_input_block",
                "element": {
                    "type": "plain_text_input",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Enter the IP address to check",
                    },
                    "action_id": "ip_input_action"
                },
                "label": {
                    "type": "plain_text",
                    "text": "IP Address",
                    "emoji": True
                }
            },
            {
                "type": "actions",
                "elements": [{
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "Check IP",
                        "emoji": True
                    },
                    "value": "check_ip",
                    "action_id": "check_ip_submit_action"  # Action
                }]
            }
        ]
        webhook.send(blocks=ip_block)


    @app.command("/check-mac")
    def handle_check_mac_command(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        mac_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Check A MAC Address",
                    "emoji": True
                }
            },
            {
                "type": "input",
                "block_id": "mac_address_input",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "mac_input"
                },
                "label": {
                    "type": "plain_text",
                    "text": "Enter MAC Address:",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "Click the button to check the MAC address."
                },
                "accessory": {
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "Check MAC Address",
                        "emoji": True
                    },
                    "value": "check_mac",
                    "action_id": "submit_mac_check"
                }
            }
        ]
        webhook.send(blocks=mac_block)


    @app.command("/create-incident")
    def handle_create_incident(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))

        incident_creation_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Incident Creation Form"
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "Select the type of incident you want to report:"
                }
            },
            {
                "type": "input",
                "block_id": "incident_type",
                "element": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Choose a type"
                    },
                    "options": [
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Incident Response"
                            },
                            "value": "ir"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Hunting"
                            },
                            "value": "hunting"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Blank"
                            },
                            "value": "blank"
                        }
                    ],
                    "action_id": "select_incident_type"
                },
                "label": {
                    "type": "plain_text",
                    "text": "Incident Type"
                }
            },
            {
                "type": "input",
                "block_id": "incident_details",
                "element": {
                    "type": "plain_text_input",
                    "multiline": True,
                    "action_id": "incident_details_input"
                },
                "label": {
                    "type": "plain_text",
                    "text": "Incident Details"
                }
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Submit Incident"
                        },
                        "style": "primary",
                        "value": "create_incident",
                        "action_id": "submit_create_incident"
                    }
                ]
            }
        ]
        webhook.send(blocks=incident_creation_block)


    @app.command("/firewall-request")
    def handle_firewall_request_command(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        params_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Firewall Tag Request Submission"
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Select a tag"
                    },
                    "options": [
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "reg-server-abusers"
                            },
                            "value": "reg-server-abusers"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "qos-bad-user"
                            },
                            "value": "qos-bad-user"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "block-bad-user"
                            },
                            "value": "block-bad-user"
                        }
                    ]
                },
                "label": {
                    "type": "plain_text",
                    "text": "Tag:"
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "plain_text_input-action"
                },
                "label": {
                    "type": "plain_text",
                    "text": "Enter a MAC Address:"
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "plain_text_input-action"
                },
                "label": {
                    "type": "plain_text",
                    "text": "Please Provide a Tag Reason:"
                }
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Submit Request"
                        },
                        "style": "primary",
                        "value": "firewall_request",
                        "action_id": "submit_firewall_request"
                    }
                ]
            }
        ]
        webhook.send(blocks=params_block)


    @app.command("/block-ip")
    def handle_block_ip_command(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        ip_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Block An IP Address",
                    "emoji": True
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "ip_address_input",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Enter IP Address",
                        "emoji": True
                    }
                },
                "label": {
                    "type": "plain_text",
                    "text": "IP Address",
                    "emoji": True
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "plain_text_input",
                    "multiline": False,
                    "action_id": "ip_details_input",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Reason for blocking",
                        "emoji": True
                    }
                },
                "label": {
                    "type": "plain_text",
                    "text": "Reason",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "Confirm to block the IP address."
                },
                "accessory": {
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "Confirm Block",
                        "emoji": True
                    },
                    "style": "danger",
                    "value": "block_ip_confirm",
                    "confirm": {
                        "title": {
                            "type": "plain_text",
                            "text": "Are you sure?"
                        },
                        "text": {
                            "type": "mrkdwn",
                            "text": "This will block the IP address from accessing the network."
                        },
                        "confirm": {
                            "type": "plain_text",
                            "text": "Yes, block it"
                        },
                        "deny": {
                            "type": "plain_text",
                            "text": "No, cancel"
                        }
                    },
                    "action_id": "confirm_block_ip"
                }
            }
        ]
        webhook.send(blocks=ip_block)


    @app.command("/xsoar-invite")
    def handle_xsoar_invite_command(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        email_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Invite to Cortex",
                    "emoji": True
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "email_invite_input",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Enter email address",
                        "emoji": True
                    }
                },
                "label": {
                    "type": "plain_text",
                    "text": "Email Address",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "Submit your email address to receive an Cortex invite."
                },
                "accessory": {
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "Send Invite",
                        "emoji": True
                    },
                    "style": "primary",
                    "value": "send_xsoar_invite",
                    "action_id": "send_xsoar_invite_action"
                }
            }
        ]
        webhook.send(blocks=email_block)


    @app.command("/menu")
    def handle_menu_command(ack, body):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        intro_text = "Explore available Slash Commands to interact with Cortex."
        command_style = "*{}*:\n_{}_"

        commands_info = [
            ("/xsoar-health", "Check Cortex's health status."),
            ("/check-ioc", "Check indicators of compromise."),
            ("/check-mac", "Retrieve details for a MAC address."),
            ("/check-ip", "Retrieve details for an IP address."),
            ("/block-ip", "Block an IP address at the firewall."),
            ("/firewall-request", "Send requests to the firewall team."),
            ("/xsoar-invite", "Request access to Cortex.")
        ]

        blocks = [
            {"type": "header", "text": {"type": "plain_text", "text": "Slash Commands"}},
            {"type": "section", "text": {"type": "mrkdwn", "text": intro_text}},
            {"type": "divider"}
        ]

        for cmd, desc in commands_info:
            blocks.append({
                "type": "section",
                "text": {"type": "mrkdwn", "text": command_style.format(cmd, desc)}
            })

        webhook.send(blocks=blocks)


    #######################
    # Slack Actions Section
    #######################

    # Check IOC Actions
    @app.action("check_ioc_select_ioc_type")
    def handle_check_ioc_select_ioc_typ(body, ack):
        ack()
        ioc_type = ""
        webhook = WebhookClient(body.get("response_url"))
        webhook.send(text="One Moment ...")
        selected_option = body['actions'][0]['selected_option']['value']

        if selected_option == "url":
            ioc_type = "URL"
        if selected_option == "ip":
            ioc_type = "IP"
        if selected_option == "domain":
            ioc_type = "Domain"
        if selected_option == "email":
            ioc_type = "Email"
        if selected_option == "sha256":
            ioc_type = "File SHA256"

        ioc_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": ioc_type + " IOC Information",
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "Minimum Reputation To Return"
                },
                "accessory": {
                    "type": "static_select",
                    "placeholder": {
                        "type": "plain_text",
                        "text": "Reputation Search Level",
                        "emoji": True
                    },
                    "initial_option": {
                        "text": {
                            "type": "plain_text",
                            "text": "Suspicious",
                            "emoji": True
                        },
                        "value": "Suspicious"
                    },
                    "options": [
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Unknown",
                                "emoji": True
                            },
                            "value": "Unknown"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Good",
                                "emoji": True
                            },
                            "value": "Good"
                        }, {
                            "text": {
                                "type": "plain_text",
                                "text": "Suspicious",
                                "emoji": True
                            },
                            "value": "Suspicious"
                        },
                        {
                            "text": {
                                "type": "plain_text",
                                "text": "Bad",
                                "emoji": True
                            },
                            "value": "Bad"
                        }
                    ],
                    "action_id": "ioc_rep_selection"  # Action
                }
            },
            {
                "type": "input",
                "element": {
                    "type": "plain_text_input",
                    "action_id": "ioc_details_input"  # Action
                },
                "label": {
                    "type": "plain_text",
                    "text": ioc_type,
                    "emoji": True
                }
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": " "
                },
                "accessory": {
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "Submit " + ioc_type,
                        "emoji": True
                    },
                    "value": "submit_ioc_check",
                    "action_id": "submit_ioc_check_action"  # Action
                }
            }
        ]

        if ioc_type != "":
            webhook.send(blocks=ioc_block)


    @app.action("ioc_rep_selection")
    def handle_ioc_rep_selection(ack):
        ack()


    @app.action("submit_ioc_check_action")
    def handle_submit_ioc_check_action(body, ack):
        ack()
        ioc_valid = False
        ioc_type = ""
        ioc_str = ""
        incident_details = ""
        incident_json = ""
        channel_name = body['channel']['name']
        channel = body['channel']['id']
        user_id = body['user']['id']
        thread = body['container']['message_ts']
        webhook = WebhookClient(body.get("response_url"))

        platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)

        if "'plain_text'" in str(body):
            results = re.search(r"'plain_text',\s+'text':\s'Submit\s(.*?)'", str(body))
            ioc_type = results.group(1)

        if "'selected_option'" in str(body):
            results = re.search(r"selected_option':\s+{.*?},\s+'value': '(.*?)'", str(body))
            reputation = results.group(1)
        else:
            reputation = "Suspicious"

        if "'plain_text_input'" in str(body):
            results = re.search(r"'plain_text_input',\s+'value': '(.*?)'", str(body))
            ioc_str = results.group(1)

        if ioc_type == "File SHA256":
            if is_sha256(ioc_str):
                ioc_valid = True
            incident_details = incident_details + "sha256=" + str(ioc_str) + "\n"
        if ioc_type == "URL":
            url_list = clean_urls(ioc_str)
            ioc_valid = True
            incident_details = incident_details + "url=" + str(url_list) + "\n"
        if ioc_type == "Domain":
            dom_list = clean_domains(ioc_str)
            ioc_valid = True
            incident_details = incident_details + "domain=" + str(dom_list) + "\n"
        if ioc_type == "IP":
            ioc_valid = True
            incident_details = incident_details + "ip=" + str(ioc_str) + "\n"
        if ioc_type == "Email":
            ioc_valid = True
            email_list = clean_emails(ioc_str)
            incident_details = incident_details + str(email_list) + "\n"
        if reputation:
            incident_details = incident_details + "reputation=" + str(reputation) + "\n"

        command_text = "check_ioc " + ioc_type + "=" + ioc_str

        mytext = incident_details + "slack_handle=" + user_id + "\nslack_thread=" + str(
            thread) + "\nchannel_name=" + channel_name + "\nslack_channel=" + channel

        if ioc_valid:
            if reputation and ioc_str and ioc_type:
                incident_json = platform_client.create_incident("Troy IOC Check", "", "Enrich IOC " + ioc_str[0:20],
                                                             SEVERITY_DICT['Low'], mytext)
            if len(str(incident_json)) > 0:
                incident_dict = return_dict(incident_json)
                incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)

                incident_block = [
                    {
                        "type": "header",
                        "text": {
                            "type": "plain_text",
                            "text": "Executing New Incident #" + incident_id,
                            "emoji": True
                        }
                    },
                    {
                        "type": "section",
                        "fields": [
                            {
                                "type": "mrkdwn",
                                "text": "*Type:*\n" + "Check IOC"
                            },
                            {
                                "type": "mrkdwn",
                                "text": "*Created by:*\n<@" + user_id + ">"
                            }
                        ]
                    },
                    {
                        "type": "section",
                        "fields": [
                            {
                                "type": "mrkdwn",
                                "text": "<" + incident_link + "| Incident #" + incident_id + " " + command_text + ">"
                            }
                        ]
                    },
                    {
                        "type": "actions",
                        "block_id": "open_incident_link",
                        "elements": [
                            {
                                "type": "button",
                                "action_id": "open_incident_link",
                                "text": {
                                    "type": "plain_text",
                                    "text": "Open Incident"
                                },
                                "url": incident_link
                            }
                        ]
                    }
                ]
            else:
                incident_block = [
                    {
                        "type": "header",
                        "text": {
                            "type": "plain_text",
                            "text": "No Data",
                            "emoji": True
                        }
                    }
                ]
        else:
            incident_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "This " + ioc_str + " is not Valid",
                        "emoji": True
                    }
                }
            ]

        webhook.send(blocks=incident_block)


    @app.action("check_ip_submit_action")
    def handle_check_ip_submit_action(body, ack):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        ip_str = ""
        channel_name = body['channel']['name']
        channel = body['channel']['id']
        user_id = body['user']['id']
        thread = body['container']['message_ts']
        if "'plain_text_input'" in str(body):
            results = re.search(r"'plain_text_input',\s+'value': '(.*?)'", str(body))
            ip_str = results.group(1)
        ip_valid = is_ip(ip_str)
        if ip_valid:
            webhook.send(text="Looking up IP Address ...")
            platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
            incident_details = "ip=" + ip_str + "\n"
            mytext = incident_details + "slack_handle=" + user_id + "\nslack_thread=" + str(
                thread) + "\nchannel_name=" + channel_name + "\nslack_channel=" + channel
            incident_json = platform_client.create_incident("Troy IP Lookup", "", "Check IP " + ip_str,
                                                         SEVERITY_DICT['Low'], mytext)
            incident_dict = return_dict(incident_json)
            incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)
            check_ip_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "New Incident #" + incident_id,
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Type:*\n" + "IP Lookup"
                        },
                        {
                            "type": "mrkdwn",
                            "text": "*Created by:*\n<@" + user_id + ">"
                        }
                    ]
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Status:*\n Working on your request!"
                        }
                    ]
                },
                {
                    "type": "actions",
                    "block_id": "open_incident_link",
                    "elements": [
                        {
                            "type": "button",
                            "action_id": "open_incident_link",
                            "text": {
                                "type": "plain_text",
                                "text": "Open Incident"
                            },
                            "url": incident_link
                        }
                    ]
                }
            ]
        else:
            check_ip_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "This IP " + ip_str + " is not Valid",
                        "emoji": True
                    }
                }
            ]
        webhook.send(blocks=check_ip_block)


    @app.action("submit_mac_check")
    def handle_submit_mac_check(body, ack):
        ack()
        webhook = WebhookClient(body.get("response_url"))

        mac_str = ""
        channel_name = body['channel']['name']
        channel = body['channel']['id']
        user_id = body['user']['id']
        thread = body['container']['message_ts']

        if "'plain_text_input'" in str(body):
            results = re.search(r"'plain_text_input',\s+'value': '(.*?)'", str(body))
            mac_str = results.group(1)

        mac_valid = is_mac(mac_str)

        if mac_valid:
            webhook.send(text="Looking up MAC Address ...")
            platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
            incident_details = "mac=" + mac_str + "\n"
            mytext = incident_details + "slack_handle=" + user_id + "\nslack_thread=" + str(
                thread) + "\nchannel_name=" + channel_name + "\nslack_channel=" + channel
            incident_json = platform_client.create_incident("Troy Mac Lookup", "", "Check MAC " + mac_str,
                                                         SEVERITY_DICT['Low'], mytext)

            incident_dict = return_dict(incident_json)
            incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)
            check_mac_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "New Incident #" + incident_id,
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Type:*\n" + "Lookup MAC Address"
                        },
                        {
                            "type": "mrkdwn",
                            "text": "*Created by:*\n<@" + user_id + ">"
                        }
                    ]
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Status:*\n Working on your request!"
                        }
                    ]
                },
                {
                    "type": "actions",
                    "block_id": "open_incident_link",
                    "elements": [
                        {
                            "type": "button",
                            "action_id": "open_incident_link",
                            "text": {
                                "type": "plain_text",
                                "text": "Open Incident"
                            },
                            "url": incident_link
                        }
                    ]
                }
            ]
        else:
            check_mac_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "This MAC " + mac_str + " is not Valid",
                        "emoji": True
                    }
                }
            ]
        webhook.send(blocks=check_mac_block)


    @app.action("submit_create_incident")
    def handle_submit_create_incident(body, ack, user_id, channel_id):
        ack()
        webhook = WebhookClient(body.get("response_url"))
        platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
        option = "Blank"
        # Grab the Option and Details
        if "'plain_text" in str(body):
            results = re.search(r"'plain_text',\s+'text':\s+'(.*?)'", str(body))
            option = results.group(1)
        if "'plain_text_input'" in str(body):
            results = re.search(r"'plain_text_input',\s+'value':\s+'(.*?)'", str(body))
            details = results.group(1)
        if option == "Incident Response":
            incident_json = platform_client.create_incident("Troy Incident Response", "",
                                                         f"Troy Incident Response Created by {user_id}"
                                                         , SEVERITY_DICT['Low'], "\nslack_handle=" + user_id
                                                         + "\nslack_channel=" + channel_id + "\n\nDetails:\n" + details)
        elif option == "Hunting":
            incident_json = platform_client.create_incident("Troy Hunting", "",
                                                         f"Troy Hunting Request Created by {user_id}"
                                                         , SEVERITY_DICT['Low'], "\nslack_handle=" + user_id
                                                         + "\nslack_channel=" + channel_id + "\n\nDetails:\n" + details)
        else:
            incident_json = platform_client.create_incident("Troy Blank", "",
                                                         f"Troy Blank Request Created by {user_id}"
                                                         , SEVERITY_DICT['Low'], "\nslack_handle=" + user_id
                                                         + "\nslack_channel=" + channel_id + "\n\nDetails:\n" + details)
        incident_dict = return_dict(incident_json)
        incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)
        response_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "New Incident #" + incident_id,
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": "*Type:*\n" + "Create Incident"
                    },
                    {
                        "type": "mrkdwn",
                        "text": "*Created by:*\n<@" + user_id + ">"
                    }
                ]
            },
            {
                "type": "actions",
                "block_id": "open_incident_link",
                "elements": [
                    {
                        "type": "button",
                        "action_id": "open_incident_link",
                        "text": {
                            "type": "plain_text",
                            "text": "Open Incident"
                        },
                        "url": incident_link
                    }
                ]
            }
        ]
        webhook.send(blocks=response_block)


    @app.action("submit_firewall_request")
    def handle_submit_firewall_request(body, ack, say):
        ack()
        channel_name = body['channel']['name']
        channel = body['channel']['id']
        user_id = body['user']['id']
        thread = body['container']['message_ts']
        input_values = []
        webhook = WebhookClient(body.get("response_url"))
        platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)

        if "'plain_text" in str(body):
            results = re.search(r"'plain_text',\s+'text':\s+'(.*?)'", str(body))
            tag = results.group(1)

        for block_id, block in body['state']['values'].items():
            if 'plain_text_input-action' in block:
                input_values.append(block['plain_text_input-action']['value'])

        incident_details = "Tag:" + tag + "\nToBeTagged:" + input_values[0] + "\nTagReason:" + input_values[1]

        mytext = incident_details + "\nslack_handle=" + user_id + "\nslack_thread=" + str(
            thread) + "\nchannel_name=" + channel_name + "\nslack_channel=" + channel

        incident_json = platform_client.create_incident("Troy Firewall Request", "",
                                                     f"Troy Firewall Request Created by {user_id}"
                                                     , SEVERITY_DICT['Low'], mytext)

        incident_dict = return_dict(incident_json)
        incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)
        response_block = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "New Incident #" + incident_id,
                    "emoji": True
                }
            },
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": "*Type:*\n" + "Firewall Request"
                    },
                    {
                        "type": "mrkdwn",
                        "text": "*Created by:*\n<@" + user_id + ">"
                    }
                ]
            },
            {
                "type": "actions",
                "block_id": "open_incident_link",
                "elements": [
                    {
                        "type": "button",
                        "action_id": "open_incident_link",
                        "text": {
                            "type": "plain_text",
                            "text": "Open Incident"
                        },
                        "url": incident_link
                    }
                ]
            }
        ]
        webhook.send(blocks=response_block)


    @app.action("confirm_block_ip")
    def handle_block_ip_action(body, ack):
        ack()
        webhook = WebhookClient(body.get("response_url"))

        ip4_str = ""
        details = ""
        channel_name = body['channel']['name']
        channel = body['channel']['id']
        user_id = body['user']['id']
        thread = body['container']['message_ts']

        if "'plain_text_input'" in str(body):
            results = re.search(r"'plain_text_input',\s+'value': '(.*?)'}},.*'plain_text_input',\s+'value': '(.*?)'",
                                str(body))
            ip4_str = results.group(1)
            details = results.group(2)

        ip_valid = is_ip(ip4_str)

        if ip_valid:
            platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
            incident_details = "ip=" + ip4_str + "\n"
            mytext = incident_details + "slack_handle=" + user_id + "\nslack_thread=" + str(
                thread) + "\nchannel_name=" + channel_name + "\nslack_channel=" + channel + "\n\nMessage:\n" + details + "\n---\n"
            incident_json = platform_client.create_incident("Troy IP Block", "", "Block IP " + ip4_str, SEVERITY_DICT['High'],
                                                         mytext)

            incident_dict = return_dict(incident_json)
            incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)
            ip_block_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "New Incident #" + incident_id,
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Type:*\n" + "Block IP"
                        },
                        {
                            "type": "mrkdwn",
                            "text": "*Created by:*\n<@" + user_id + ">"
                        }
                    ]
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Status:*\n Asking Approval"
                        }
                    ]
                },
                {
                    "type": "actions",
                    "block_id": "open_incident_link",
                    "elements": [
                        {
                            "type": "button",
                            "action_id": "open_incident_link",
                            "text": {
                                "type": "plain_text",
                                "text": "Open Incident"
                            },
                            "url": incident_link
                        }
                    ]
                }
            ]
        else:
            ip_block_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "This IP is not Valid",
                        "emoji": True
                    }
                }
            ]

        webhook.send(blocks=ip_block_block)


    @app.action("send_xsoar_invite_action")
    def handle_send_xsoar_invite_action(body, ack, say):
        ack()
        email_str = ""
        channel_name = body['channel']['name']
        channel = body['channel']['id']
        user_id = body['user']['id']
        thread = body['container']['message_ts']
        platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
        if "'plain_text_input'" in str(body):
            results = re.search(r"'plain_text_input',\s+'value': '(.*?)'", str(body))
            email_str = results.group(1)
        webhook = WebhookClient(body.get("response_url"))
        email_valid = is_email(email_str)
        if email_valid:
            incident_details = "email=" + email_str + "\n"
            mytext = incident_details + "slack_handle=" + user_id + "\nslack_thread=" + str(
                thread) + "\nchannel_name=" + channel_name + "\nslack_channel=" + channel
            incident_json = platform_client.create_incident("Troy Cortex Invite", "", "Cortex Invite " + email_str[0:20],
                                                         SEVERITY_DICT['Low'], mytext)
            incident_dict = return_dict(incident_json)
            incident_link, incident_id = get_incident_link(platform_client, PLATFORM, PLATFORM_URL,incident_dict)
            invite_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "New Incident #" + incident_id,
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": "*Type:*\n" + "Send Platform Invite"
                        },
                        {
                            "type": "mrkdwn",
                            "text": "*Created by:*\n<@" + user_id + ">"
                        }
                    ]
                },
                {
                    "type": "actions",
                    "block_id": "open_incident_link",
                    "elements": [
                        {
                            "type": "button",
                            "action_id": "open_incident_link",
                            "text": {
                                "type": "plain_text",
                                "text": "Open Incident"
                            },
                            "url": incident_link
                        }
                    ]
                }
            ]
        else:
            invite_block = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": "This Email is not Valid",
                        "emoji": True
                    }
                }
            ]
        webhook.send(blocks=invite_block)


    @app.action("approve_button")
    def handle_approve_request(ack, say):
        ack()
        say("Request approved!")


    @app.action("open_incident_link")
    def handle_open_incident_link(ack, say):
        ack()


    @app.action("rejection_button")
    def handle_approve_request(ack, say):
        ack()
        say("Request rejected!")


    def test_module():
        # 1. Verify Basic Connectivity (Legacy)
        platform_client = get_client(PLATFORM, PLATFORM_URL, API_KEY, API_KEY_ID)
        try:
            platform_client.health()
        except Exception as e:
            return_error(f"XSIAM Health Check Failed: {str(e)}")

        # 2. Verify Agent MCP Check (New)
        demisto.info("Testing Agent MCP Integration...")
        prompt = """
        {
          "method": "tools/call",
          "params": {
            "name": "get_cases",
            "arguments": {
              "filters": [],
              "search_from": 0,
              "search_to": 30,
              "sort": null
            }
          }
        }
        """
        # We ask the model to perform this call (or interpret this JSON as a command to call)
        # Actually, the user asked to "prompt the model for an mcp call like...".
        # This implies we send this JSON as the prompt? Or we send a natural language prompt that RESULTS in this?
        # User said: "prompt the model for an mcp call like {...}"
        # Interpreting: "Please call get_cases with these arguments"

        # Let's try a direct instruction which is more robust for a test.
        test_prompt = "Call the get_cases tool with default arguments (search_from=0, search_to=30)."

        response = get_gemini_response(test_prompt)

        # Check for success indicators
        if "Error" in response or "brain freeze" in response:
            return_error(f"Agent/MCP Test Failed: {response}")

        # If successful, 'results' should be in the response or a confirmation.
        # Since run_agent_async returns the final text, and we are not seeing the intermediate tool call in the return value unless we log it.
        # But if it returns a normal string response (e.g. "Here are the cases..."), it worked.
        gemini_out = f"XSIAM Connectivity: OK\nAgent/MCP Test: OK\nResponse: {response[:200]}..."
        demisto.results('ok') # 'ok' is the standard success for test-module
        demisto.info(gemini_out)

    def download_thread_file():
        download_link = demisto.args().get('file_link')
        file_name = demisto.args().get("file_name", "slackfile")

        headers = {
            "Authorization": f"Bearer {BOT_TOKEN}"
        }
        response = requests.get(download_link, headers=headers)
        try:
            if response.status_code == 200:
                return_results(fileResult(file_name, response.content))
            else:
                return_results ("Failed to download the file.")
        except Exception as e:
            demisto.error(f"Failed to download the file: {str(e)}")


    def get_thread_messages():
        channel_id = demisto.args().get("channel_id")
        thread_id = demisto.args().get("thread_id")
        updated_messages = []
        warroom_entries = []
        messages_url = f"https://slack.com/api/conversations.replies?channel={channel_id}&ts={thread_id}"
        headers = {
            "Authorization": f"Bearer {BOT_TOKEN}"
        }
        raw_response = requests.get(messages_url, headers=headers)
        if not raw_response.json().get('ok'):
            error = raw_response.get('error')
            return_error(f'An error occurred while listing conversation replies: {error}')

        messages = raw_response.json().get('messages', '')
        if isinstance(messages, dict):
            messages = [messages]
        if not isinstance(messages, list):
            demisto.error(f'An error occurred while listing conversation replies: {raw_response.get("error")}')
        for message in messages:
            name = 'N/A'
            full_name = 'N/A'
            if 'subtype' not in message:
                user_id = message.get('user')
                user_url = f"https://slack.com/api/users.info?user={user_id}"
                user_details_response = requests.get(user_url, headers=headers)
                user_details = user_details_response.json().get('user')
                name = user_details.get('name')
                full_name = user_details.get('real_name')
            message['user_name'] = name
            message['full_name'] = full_name
            updated_messages.append(message)

            warroom_entry = {
                'Type': message.get('type'),
                'Text': message.get('text'),
                'UserId': message.get('user'),
                'Name': name,
                'FullName': full_name,
                'TimeStamp': message.get('ts'),
                'ThreadTimeStamp': message.get('thread_ts')
            }
            warroom_entries.append(warroom_entry)
        readable_output = tableToMarkdown(f'Thread Messages of thread - {thread_id}', warroom_entries)
        return_results(CommandResults(
            outputs_prefix='Slack.Thread.Messages',
            outputs_key_field='',
            outputs=updated_messages,
            readable_output=readable_output
        ))

    def long_running_main():
        """
        Starts the long running thread.
        """
        try:
            asyncio.run(SocketModeHandler(app, APP_TOKEN).start(), debug=True)
        except Exception as e:
            demisto.error(f"The Loop has failed to run {str(e)}")
        finally:
            loop = asyncio.get_running_loop()
            try:
                loop.stop()
                loop.close()
            except Exception as e_:
                demisto.error(f'Failed to gracefully close the loop - {e_}')





    def main() -> None:
        """
        Main
        """
        global app, EXTENSIVE_LOGGING, debug_start, verify_ssl, platform_client

        if SSL_VERIFY == False:
            urllib3.disable_warnings()

        commands = {
            'test-module': test_module,
            'long-running-execution': long_running_main,
            'slackbot-download-thread-file': download_thread_file,
            'slackbot-get-thread-messages': get_thread_messages
        }

        command_name: str = demisto.command()

        try:
            demisto.info(f'{command_name} started.')
            command_func = commands[command_name]
            support_multithreading()
            command_func()
        except Exception as e:
            return_error(str(e))
        finally:
            demisto.info(f'{command_name} completed.')  # type: ignore


    ''' ENTRY POINT '''
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  dockerimage: aymanam/eset:slackbot-latest
  subtype: python3
  runonce: false
  longRunning: true
sourcemoduleid: SlackBot
